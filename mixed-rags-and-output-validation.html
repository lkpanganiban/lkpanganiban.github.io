<!doctype html>
<html lang="en" itemscope itemtype="http://schema.org/Person">
<head>
            <meta charset="utf-8">
        <!-- Site Meta Data -->
        <title>Mixed RAGs and Output Validation</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="Ian Panganiban">

        <link rel="shortcut icon" href="https://www.lkpanganiban.com/theme/images/icons/favicon.png">

        <!-- schema.org -->
        <meta itemprop="name" content="lkpanganiban.com">
        <meta itemprop="image" content="">
        <meta itemprop="description" content="">

        <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700' rel='stylesheet' type='text/css'>
        <!-- Style Meta Data -->
        <link rel="stylesheet" href="https://www.lkpanganiban.com/theme/css/style.css" type="text/css"/>
        <link rel="stylesheet" href="https://www.lkpanganiban.com/theme/css/pygments.css" type="text/css"/>

        <!-- Feed Meta Data -->

        <!-- Twitter Feed -->
        <meta name="twitter:card" content="summary">
        <meta name="twitter:site" content="">
        <meta name="twitter:image" content="">

    <meta name="twitter:creator" content="">
    <meta name="twitter:url" content="https://www.lkpanganiban.com/mixed-rags-and-output-validation.html">
    <meta name="twitter:title" content="lkpanganiban.com ~ Mixed RAGs and Output Validation">
    <meta name="twitter:description" content="From the previous blogpost about RAG with Llama Index, I&#39;ve gone through how about developing RAGs with Llama Index, a library to create LLM applications. For this post, I have extended my experiment to mix vector and text based algorithms of vectors and bag of words. From the previous blogpost …">

    <!-- Facebook Meta Data -->
    <meta property="og:title" content="lkpanganiban.com ~ Mixed RAGs and Output Validation"/>
    <meta property="og:description" content="From the previous blogpost about RAG with Llama Index, I&#39;ve gone through how about developing RAGs with Llama Index, a library to create LLM applications. For this post, I have extended my experiment to mix vector and text based algorithms of vectors and bag of words. From the previous blogpost …"/>
    <meta property="og:image" content=""/>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-PQC0GXQ1JC"></script>
        <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-PQC0GXQ1JC');
        </script>
</head>

<body>
<!-- Sidebar -->
<aside>
    <center><a href="https://www.lkpanganiban.com"><img id="avatar" src="https://www.lkpanganiban.com/images/ian.jpg"></a></center>
    <h1>lkpanganiban.com</h1>
        <p>Geo Programmer | ian.panganiban@outlook.ph</p>
    <br>


    <nav class="nav">
        <ul class="list-bare">


                <li><a class="nav__link" href="https://www.lkpanganiban.com/pages/profile.html">Profile</a></li>
                <li><a class="nav__link" href="https://www.lkpanganiban.com/pages/projects.html">Projects</a></li>

        </ul>
    </nav>

    <p class="social">
                <a href="https://www.linkedin.com/in/ian-panganiban/" target="_blank"><img
                        src="https://www.lkpanganiban.com/theme/images/icons/linkedin.png"></a>
                <a href="https://github.com/lkpanganiban" target="_blank"><img
                        src="https://www.lkpanganiban.com/theme/images/icons/github.png"></a>
                <a href="https://twitter.com/lkpanganiban" target="_blank"><img
                        src="https://www.lkpanganiban.com/theme/images/icons/twitter.png"></a>
    </p>

        <h2>Categories</h2>
        <ul class="navbar">
                <li class="active"><a
                        href="https://www.lkpanganiban.com/category/blog.html">blog</a></li>
                <li><a
                        href="https://www.lkpanganiban.com/category/guides.html">guides</a></li>
        </ul>


</aside>

<!-- Content -->
<article>
    <section id="content">
        <article>
            <h2 class="post_title post_detail"><a href="https://www.lkpanganiban.com/mixed-rags-and-output-validation.html" rel="bookmark"
                                                  title="Permalink to Mixed RAGs and Output Validation">Mixed RAGs and Output Validation</a></h2>
            <div class="entry-content blog-post">
                <p>From the previous blogpost about RAG with Llama Index, I've gone through how about developing RAGs with Llama Index, a library to create LLM applications. For this post, I have extended my experiment to mix vector and text based algorithms of vectors and bag of words.</p>
<p>From the <a href="https://www.lkpanganiban.com/rag-with-llama-index.html">previous blogpost</a> about RAG with Llama Index, I've gone through how about developing RAGs with Llama Index, a library to create LLM applications. For this post, I have extended my experiment to mix vector and text based algorithms of vectors and bag of words.</p>
<h1>Bag of Words and Retrievals</h1>
<p>In most search or indexing databases like Elasticsearch, Opensearch, and Solr, the general algorithms being used are <a href="https://en.wikipedia.org/wiki/Okapi_BM25">Best Matching (BM25)</a> and the <a href="https://en.wikipedia.org/wiki/Tf%E2%80%93idf">term-frequency/inverse-document-frequency (TF/IDF)</a>. It basically generates a relevance score that will be used to rank the entries in the database. Both of these fall under the bag of words type of algorithms where the existence and occurence of a word drive the relevance. The simplified steps on how bag of words pipeline are the following:</p>
<ol>
<li>Read and parse the data source.</li>
<li>Identify the unique words in the data entry, stem words, and remove stop words. <em>Depends on the word dictionary that you will use. Some stop are the following: <code>and, are, that, then, there, such</code>.</em></li>
<li>Store the unique words with the <code>id</code> of the data/document entry in an <code>index</code>. E.g. Hello -&gt; [Doc1, Doc2] and World -&gt; [Doc2]</li>
<li>A prompt will be fed and parsed. <em>Removes the stopwords, tokenization, and/or implement stemming.</em></li>
<li>Using the output of 4, return the entries that have a hit.</li>
<li>Implement scoring using the term counts, total unique words, total words in the corpus, etc.</li>
<li>Return the top <code>N</code> results and present the results to user.</li>
</ol>
<p>The general issue that comes up with these types of algorithms is that it does not take into account synonymous words or even the position of the term. As an example, <code>with resource</code> and <code>without resource</code> may have the same relevance score if the user is looking for <code>resource</code>; this is due the algorithm only uses the <code>resource</code> term as the input to generate the relevance. There are ways to consider this use case by setting up keywords or even modifying the score by detecting the words that will provide more context; the issue though is that you will need to hard-coding all of the use cases. That is why a lot of AI or ML workflows are using more on the vector retrieval as against to bag of words.</p>
<p>The good thing about these types of algorithms though is that they are less complex by term counts meaning it is less complex and more explainable to the user. ML or embedding based retrievals introduce additional complexity by adding chunking, overlaps, data where the model was trained on, conversion to vector space, etc. Given these additional complexities, the embedding approach is computationally expensive.</p>
<h1>Vector and Embedding-based Retrievals</h1>
<p>Due to the expansion of the new thing which is ML or AI in general, the proliferation of vector stores available either proprietary or open source are on the rise and traditional database technologies are creating use cases or adding support to execute vector retrievals.</p>
<p>In the my previous blogpost, to implement a sample RAG using Llama Index, it needs to convert the entries from the data source into a vector and stores it into a vector store by using embedding models. When storing these vectors the associated metadata can either be the ID or even the actual text is also stored in the vector store. The simplified steps on how to implement this pipeline are the following:</p>
<ol>
<li>Read and parse the data source.</li>
<li>Pass the data source into the embedding model and thus generating a vector - we can call this as <code>Data Vector</code> E.g. <code>Hello World</code> =&gt; <code>[0.1021, 0.3341]</code></li>
<li>Store the output into a vector store.</li>
<li>A prompt or question will be fed into the vector store. This will repeat step 2. We can call this as <code>Prompt Vector</code>.</li>
<li>Implement a search by comparing (clustering - e.g. KNN, cosine similarity) the distance of <code>Prompt Vector</code> with the various <code>Data Vectors</code>.</li>
<li>Sort the distances.</li>
<li>Return the top <code>N</code> Data Vectors together with the metadata. Present the results.</li>
</ol>
<p>Based on the steps, the search and retrieval is dependent on the vector computation and distances instead of term occurence. As mentioned in the bag of words section, even though this will solve the hardcoding and positional issues the vector is dependent on the data the embedded model is trained on.</p>
<h1>Vector + Bag of Words</h1>
<p>I am quite curious how the mixing of BM25 and vector retrieval algorithms will affect in the output result of the LLM. For this, I have implemented a <a href="https://github.com/lkpanganiban/llama-index-experiment/blob/main/implementations/llama_mix_rags_weaviate.ipynb">notebook</a> showing the difference between the two algorithms. I will be using <a href="https://www.llamaindex.ai/">Llama Index</a> and <a href="https://weaviate.io/">Weaviate</a> for this experiement. <em>Weaviate can be installed using a <a href="https://weaviate.io/developers/weaviate/installation/docker-compose">docker-compose.yml</a>.</em></p>
<h1>Experiment Notes</h1>
<ul>
<li>The consideration using Weaviate due to its out of the box support to BM25 and vector retrieval is good for maintainability point of view. You don't want to have different databases for Vector and Textual searches. <em>You can use other combination of databases as you like for this like Elasticsearch, Pinecone, and PostgreSQL + PGVector.</em></li>
<li>To evaluate the results, feeding the generated response to another LLM to make the decision which one to use is good for an automation point of view. If you can fine-tune the evaluator model based on the target audience will be very handy since it can help in re-wording some of the terms to the target audience e.g Non-domain audience.</li>
<li>The results of the vector retrieval did not change a lot. I think this is due that we are querying something specific like steps in a handbook or instructions. <em>Maybe if we expand to other workloads and use cases like news articles or forum posts, the outputs will differ.</em></li>
</ul>
            </div>
            <div class="post_list">
                <span>By </span>
                <a href="https://www.lkpanganiban.com/author/ian-panganiban.html">@Ian Panganiban</a>
                <span> in </span>
                <span class="post_category"><a href="https://www.lkpanganiban.com/category/blog.html" rel="bookmark"
                                               title="Permalink to blog">[ blog ]</a></span>
                <span class="post_date">Sat 30 September 2023</span>
                <div><span>Tags : </span>
                            <span><a href="https://www.lkpanganiban.com/tag/llms.html">#llms, </a></span>
                            <span><a href="https://www.lkpanganiban.com/tag/experiments.html">#experiments, </a></span>
                </div>

                <div class="entry-social">
                    <span class="mail"><a
                        href="mailto:?subject=Mixed RAGs and Output Validation&amp;body=Viens découvrir un article à propos de [Mixed RAGs and Output Validation] sur le site de Ian Panganiban. https://www.lkpanganiban.com/mixed-rags-and-output-validation.html"
                        title="Share by Email" target="_blank"><img
                        src="https://www.lkpanganiban.com/theme/images/icons/mail-s.png"></a></span>

                        <a target="_blank" title="Linkedin"
                        href="https://www.linkedin.com/shareArticle?mini=true&url=https://www.lkpanganiban.com/mixed-rags-and-output-validation.html&title=Mixed RAGs and Output Validation"
                        rel="nofollow"
                        onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=450,width=650');return false;"><img
                             src="https://www.lkpanganiban.com/theme/images/icons/linkedin-s.png"></a>
 
                    <span class="twitter"><a target="_blank" rel="nofollow"
                                             onclick="javascript:window.open(this.href, '', 'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=400,width=700');return false;"
                                             title="Twitter"
                                             href="https://twitter.com/share?url=https://www.lkpanganiban.com/mixed-rags-and-output-validation.html&text=Mixed RAGs and Output Validation&via="><img
                            src="https://www.lkpanganiban.com/theme/images/icons/twitter-s.png"></a></span>


                </div>
            </div>
        </article>
    </section>
</article>

<!-- Footer -->
    <footer>
        <p>
            Blog powered by <a href="http://getpelican.com/">Pelican</a>,
            which takes great advantage of <a href="http://python.org">Python</a>.
            Theme <a href="https://github.com/parbhat/pelican-blue">Pelican-Blue</a> by <a
                href="https://parbhatpuri.com/">@parbhat</a>.
        </p>
    </footer>


</body>
</html>